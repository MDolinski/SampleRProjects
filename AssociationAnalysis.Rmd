---
title: "Analiza asocjacji w R"
author: Mateusz Dolinski
date: 10.03.2018
output:
  html_notebook:
    theme: united
    toc: yes
    toc_float: yes
editor_options: 
  chunk_output_type: inline
---

# Wstep
Celem tego dokumentu jest zastosowanie analizy asocjacji do rozwiazania praktycznego problemu na zbiorze danych medycznych: na podstawie informacji o wizytach pacjentow nalezy wskazac pary chorob, ktore 'czesto wystepuja razem'. Rozwiazanie przygotowane jest w nastepujacej formie: na poczatku przedstawiono opis danych i zastosowanego podejscia. Nastepnie krok po kroku scharakteryzowano wykonane transformacje na danych. Na koncu opisano wyniki i ich wizualizacje.

Rozwiazanie zostalo napisane w pakiecie statystycznym R przy uzyciu nastepujacych bibliotek:

* [plyr](https://cran.r-project.org/web/packages/plyr/plyr.pdf)
* [arules](https://cran.r-project.org/web/packages/arules/arules.pdf)
* [arulesViz](https://cran.r-project.org/web/packages/arulesViz/vignettes/arulesViz.pdf)
* [rainbow](https://cran.r-project.org/web/packages/rainbow/rainbow.pdf)
* [ggplot2](https://cran.r-project.org/web/packages/ggplot2/ggplot2.pdf)

# Zbior danych i podejscie do problemu
Otrzymany zbior danych jest rejestrem wizyt pacjentow. Ma on 22114 rekordow od 5000 pacjentow. Kazdy wiersz sklada sie z trzech kolumn:

* date_num - data a dokładnie dzień, ale zakodowany w postaci liczby. Im liczba mniejsza tym starsza wizyta.
* patient_id - kod pacjenta. Wiersze z tym samym kodem dotyczą tego samego pacjenta.
* rec1_code - kod choroby zapisany za pomocą Klasyfikacji Chorób [ICD 10](https://en.wikipedia.org/wiki/ICD-10)

Rozwiazaniem problemu jest odnalezienie tzw. czestych chorob (ang. *frequent itemsets*). Niech C będzie zbiorem wszystkich chorob. Powiemy, ze zbior A, będący podzbiorem C, jest zbiorem czestym o wsparciu s jezeli odsetek wszystkich pacjentow cierpiacych na choroby w zadanym zbiorze danych wynosi s. Na podstawie zbiorow czestych mozna odnalezc reguly decyzyjne. Regula decyzyjna jest to wnioskowanie postaci A => B gdzie A i B to podzbiory C. Mowimy, ze regula decyzyjna ma pewnosc c jesli stosunek wsparcia sumy zbiorow A i B do wsparcia zbioru A jest niemniejszy od c. Do znajdowania zbiorow czestych oraz regul decyzyjnych posluzy nam algorytm [apriori](https://pl.wikipedia.org/wiki/A_priori) oraz jego implementacja w bibliotece arules.

```{r, echo = FALSE}
library(pacman)
p_load(plyr,
       arules,
       arulesViz, 
       rainbow, 
       ggplot2)
```

# Transformacja danych
Na poczatku wczytany zotal zbior danych:
```{r}
DATA <- read.csv("C:/Users/Mateusz/Downloads/zadanie0.tsv",
                 sep = "\t")
```
Nastepnie z kazdego kodu choroby wyciagnieta zostal pierwszy znak przy pomocy funkcji gsub:
```{r}
DATA$rec1_code <- gsub("^(.).*",
                       "\\1", 
                       DATA$rec1_code,
                       perl = T)
```
Kolejnym etapem bylo przeksztalcenie zbioru danych do formatu akceptowanego przez paczke arules. W tej analizie zdecydowano sie na agregacje danych na poziomie pojedynczego pacjenta. Pozbyto sie zatem kolumny date_num, a nastepnie zapisano dane do tymczasowego pliku "test.csv", skad nastepnie wczytano dane do biblioteki arules przy pomocy funkcji `read.transactions()`:
```{r}
DATA$date_num <- NULL
write.csv(DATA, 'data_correct_format.csv', row.names = F)
DATA_APRIORI <- read.transactions('data_correct_format.csv',
                                  rm.duplicates = T,
                                  format = "single",
                                  sep = ",",
                                  cols = c(1, 2),
                                  skip = 1)

```
# Wyniki analizy asocjacji
Na obiekcie `DATA_APRIORI` zapuszczono algorytm znajdujacy czeste podzbiory chorob. Ustawiony parametr `supp` na poziomie 0.04 jest wyborem arbitralnym, choc stoi za nim pewna interpretacja: poszukujemy kodow chorob wystepujacych naraz u co najmniej 4% wszystkich pacjentow:
```{r}
frequent_itemsets <- eclat(DATA_APRIORI, 
                           parameter = list(supp = 0.04))
summary_frequent <- inspect(frequent_itemsets)
```
Otrzymano 17 zbiorow spelniajacych powyzszy warunek. Sprawdzono wyniki obliczen, obliczajac na boku wsparcie dwoch losowych singletonow. Wykorzystano w tym celu funkcje `ddply()` z pakietu plyr:
```{r}
DATA_BASKET_FORMAT <- ddply(DATA,
                            c("patient_id"), 
                            function(data_frame) {
                              paste(data_frame$rec1_code, 
                                    collapse = ",")
                            })
DATA_BASKET_FORMAT$V1 <- sapply(DATA_BASKET_FORMAT$V1 , 
                                function(x) {
                                  paste(sort(unique(unlist(strsplit(x,
                                                                    split = ',')))),
                                        collapse = ',')
                                })
sprintf('Support for {Z} = %.4f',
        sum(sapply(DATA_BASKET_FORMAT[, 2],function(x) grepl('Z', x))) / 
          length(unique(DATA[, 1])))
sprintf('Support for {G} = %.4f',
        sum(sapply(DATA_BASKET_FORMAT[, 2],function(x) grepl('G', x))) / 
          length(unique(DATA[, 1])))
```
Wyniki obliczen wykonywanych przez biblioteke sa poprawne. Ponizej zamieszczono ich wizualizacje przy pomocy funkcji `itemFrequencyPlot` z biblioteki arulesViz:
```{r fig.align="center"}
rainbowcols <- rainbow(nrow(summary_frequent))
itemFrequencyPlot(DATA_APRIORI,
                  support = 0.04,
                  cex.names = 0.8,
                  col = rainbowcols)
```
Zauwazmy jednak, ze zbiory z wyniku zawieraja singletony, podczas gdy poszukiwane sa choroby wspolwystepujace. Zmodyfikowano wiec API i stworzono wlasna wizualizacje. Wykorzystano w tym celu pakiet ggplot2: 
```{r fig.align="center"}
summary_frequent <- summary_frequent[sapply(as.character(summary_frequent$items), 
                                            nchar) > 3, ]
summary_frequent
summary_frequent$order <- order(summary_frequent$support, 
                                decreasing = T)
ggplot(data.frame(summary_frequent), 
       aes(x = reorder(items, -support),
           y = support, fill = items)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label= round(support, 3)),
            position=position_dodge(width = 0.9),
            vjust = -0.25) +
  theme(panel.background = element_rect(fill = 'white', 
                                        colour = 'black'),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none")
```
Na koniec przeprowadzono analize asocjacji w celu znalezienia regul decyzyjnych o pewnosci co najmniej 50%:
```{r}
disease_rules <- apriori(DATA_APRIORI,
                         parameter = list(supp = 0.04, 
                                          conf = 0.5,
                                          target="rules"))
inspect(disease_rules)
```
Otrzymano 2 reguly decyzyjne. Ponizej zamieszczono ich wizualizacje:
```{r fig.align="center"}
plot(disease_rules, 
     method = "grouped")
plot(disease_rules)
```


# Podsumowanie 
Otrzymano 5 par chorob wspolwystepujacych. Sa to:

* (J, Z)
* (H, J)
* (N, Z)
* (M, Z)
* (J, R)

oraz dwie reguly decyzyjne:

* ( R ) => (J)
* ( N ) => (Z)

Reguły decyzyjne mają wsparcie na poziomie nieznacznie przekraczajacym 50%.

Najczesciej wspolwystepujaca para chorob wystepuje u ponad 11% pacjentow. Otrzymane wyniki moga zostac odkodowane i przekazane sektorowi medycznemu.